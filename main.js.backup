require('./config')
const { 
    default: makeWASocket, 
    useMultiFileAuthState, 
    DisconnectReason, 
    fetchLatestBaileysVersion, 
    generateForwardMessageContent, 
    prepareWAMessageMedia, 
    generateWAMessageFromContent, 
    generateMessageID, 
    downloadContentFromMessage, 
    makeInMemoryStore, 
    jidDecode, 
    getAggregateVotesInPollMessage, 
    proto,
    makeCacheableSignalKeyStore,
    PHONENUMBER_MCC
} = require("@whiskeysockets/baileys")
const WebSocket = require('ws')
const path = require('path')
const fs = require('fs')
const NodeCache = require("node-cache")
const yargs = require('yargs/yargs')
const cp = require('child_process')
const _ = require('lodash')
const syntaxerror = require('syntax-error')
const P = require('pino')
const os = require('os')
const { Boom } = require('@hapi/boom')
const readline = require('readline')

// Pairing code settings
const pairingcode = process.argv.includes('--pairing-code')
const useMobile = process.argv.includes('--mobile')
const pairingNumber = process.env.PAIRING_NUMBER || ""

let simple = require('./lib/simple')

// Use local lowdb (always compatible)
const { Low, JSONFile } = require('./lib/lowdb')
const mongoDB = require('./lib/mongoDB')

global.API = (name, path = '/', query = {}, apikeyqueryname) => (name in global.APIs ? global.APIs[name] : name) + path + (query || apikeyqueryname ? '?' + new URLSearchParams(Object.entries({ ...query, ...(apikeyqueryname ? { [apikeyqueryname]: global.APIKeys[name in global.APIs ? global.APIs[name] : name] } : {}) })) : '')

global.timestamp = {
  start: new Date
}

const PORT = process.env.PORT || 3000

global.opts = new Object(yargs(process.argv.slice(2)).exitProcess(false).parse())
global.prefix = new RegExp('^[' + (opts['prefix'] || '‎xzXZ/i!#$%+£¢€¥^°=¶∆×÷π√✓©®:;?&.\\-').replace(/[|\\{}()[\]^$+*?.\-\^]/g, '\\$&') + ']')

global.db = new Low(
  /https?:\/\//.test(opts['db'] || '') ?
    new cloudDBAdapter(opts['db']) : /mongodb/.test(opts['db']) ?
      new mongoDB(opts['db']) :
      new JSONFile(`${opts._[0] ? opts._[0] + '_' : ''}database.json`)
)
global.DATABASE = global.db

global.loadDatabase = async function loadDatabase() {
  if (global.db.READ) return new Promise((resolve) => setInterval(function () { (!global.db.READ ? (clearInterval(this), resolve(global.db.data == null ? global.loadDatabase() : global.db.data)) : null) }, 1 * 1000))
  if (global.db.data !== null) return
  global.db.READ = true
  await global.db.read()
  global.db.READ = false
  global.db.data = {
    users: {},
    chats: {},
    stats: {},
    msgs: {},
    sticker: {},
    settings: {},
    ...(global.db.data || {})
  }
  global.db.chain = _.chain(global.db.data)
}
loadDatabase()

const question = (text) => {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  })
  return new Promise((resolve) => {
    rl.question(text, (answer) => {
      rl.close()
      resolve(answer)
    })
  })
}

// Wrap everything in async IIFE
async function startBot() {
  global.authFile = 'session'
  const { state, saveCreds } = await useMultiFileAuthState(`./${authFile}`)

  // Fetch latest Baileys version
  const { version, isLatest } = await fetchLatestBaileysVersion()
  console.log(`Using WhatsApp v${version.join('.')}, isLatest: ${isLatest}`)

  const msgRetryCounterCache = new NodeCache()

  // Connection options
  const connectionOptions = {
      version,
      logger: P({ level: "silent" }),
      printQRInTerminal: !pairingcode,
      mobile: useMobile, 
      browser: ['Chrome (Linux)', '', ''],
      auth: {
          creds: state.creds,
          keys: makeCacheableSignalKeyStore(state.keys, P({ level: "silent" }))
      },
      msgRetryCounterCache,
      generateHighQualityLinkPreview: true,
      getMessage: async (key) => {
          return {
              conversation: 'hello'
          }
      }
  }

  global.conn = simple.makeWASocket(connectionOptions)

  // Database auto-save
  if (!opts['test']) {
    if (global.db) setInterval(async () => {
      if (global.db.data) await global.db.write()
      if (opts['autocleartmp'] && (global.support || {}).find) {
          let tmp = [os.tmpdir(), 'tmp']
          tmp.forEach(filename => cp.spawn('find', [filename, '-amin', '3', '-type', 'f', '-delete']))
      }
    }, 30 * 1000)
  }

  // Connection update handler
  async function connectionUpdate(update) {
    const { connection, lastDisconnect, isNewLogin } = update
    
    global.stopped = connection
    
    if (isNewLogin) {
      global.db.data = { users: {}, chats: {}, stats: {}, msgs: {}, sticker: {}, settings: {} }
    }

    if (connection === 'close') {
      let reason = new Boom(lastDisconnect?.error)?.output.statusCode
      if (reason === DisconnectReason.badSession) {
        console.log(`Bad Session File, Please Delete Session and Scan Again`)
        process.exit()
      } else if (reason === DisconnectReason.connectionClosed) {
        console.log('Connection closed, reconnecting....')
        startBot()
      } else if (reason === DisconnectReason.connectionLost) {
        console.log('Connection Lost from Server, reconnecting...')
        startBot()
      } else if (reason === DisconnectReason.connectionReplaced) {
        console.log('Connection Replaced, Another New Session Opened, Please Close Current Session First')
        process.exit()
      } else if (reason === DisconnectReason.loggedOut) {
        console.log(`Device Logged Out, Please Scan Again And Run.`)
        process.exit()
      } else if (reason === DisconnectReason.restartRequired) {
        console.log('Restart Required, Restarting...')
        startBot()
      } else if (reason === DisconnectReason.timedOut) {
        console.log('Connection TimedOut, Reconnecting...')
        startBot()
      } else {
        console.log(`Unknown DisconnectReason: ${reason}|${connection}`)
        startBot()
      }
    }

    if (connection === 'open') {
      console.log('✅ Connected to WhatsApp')
    }

    if (global.db.data == null) await loadDatabase()
  }

  // Pairing code handler
  if (pairingcode && !conn.authState.creds.registered) {
      if (useMobile) throw new Error('Cannot use pairing code with mobile api')

      let phoneNumber
      if (!!pairingNumber) {
          phoneNumber = pairingNumber.replace(/[^0-9]/g, '')

          if (!Object.keys(PHONENUMBER_MCC).some(v => phoneNumber.startsWith(v))) {
              console.log("Start with your country's WhatsApp code, Example : 62xxx")
              process.exit(0)
          }
      } else {
          phoneNumber = await question('Please type your WhatsApp number : ')
          phoneNumber = phoneNumber.replace(/[^0-9]/g, '')

          if (!Object.keys(PHONENUMBER_MCC).some(v => phoneNumber.startsWith(v))) {
              console.log("Start with your country's WhatsApp code, Example : 62xxx")
              phoneNumber = await question('Please type your WhatsApp number : ')
              phoneNumber = phoneNumber.replace(/[^0-9]/g, '')
          }
      }

      setTimeout(async () => {
          let code = await conn.requestPairingCode(phoneNumber)
          code = code?.match(/.{1,4}/g)?.join('-') || code
          console.log(`Your Pairing Code : ${code}`)
      }, 3000)
  }

  process.on('uncaughtException', console.error)

  // Plugin loader
  const imports = (path) => {
    path = require.resolve(path)
    let modules, retry = 0
    do {
      if (path in require.cache) delete require.cache[path]
      modules = require(path)
      retry++
    } while ((!modules || (Array.isArray(modules) || modules instanceof String) ? !(modules || []).length : typeof modules == 'object' && !Buffer.isBuffer(modules) ? !(Object.keys(modules || {})).length : true) && retry <= 10)
    return modules
  }

  let isInit = true
  global.reloadHandler = function (restatConn) {
    let handler = imports('./handler')
    if (restatConn) {
      try { global.conn.ws.close() } catch { }
      global.conn = {
        ...global.conn, ...simple.makeWASocket(connectionOptions)
      }
    }
    if (!isInit) {
      conn.ev.off('messages.upsert', conn.handler)
      conn.ev.off('group-participants.update', conn.participantsUpdate)
      conn.ev.off('message.delete', conn.onDelete)
      conn.ev.off('connection.update', conn.connectionUpdate)
      conn.ev.off('creds.update', conn.credsUpdate)
    }

    conn.welcome = 'Hai, @user!\nSelamat datang di grup @subject\n\n@desc'
    conn.bye = 'Selamat tinggal @user!'
    conn.spromote = '@user sekarang admin!'
    conn.sdemote = '@user sekarang bukan admin!'
    conn.handler = handler.handler.bind(conn)
    conn.participantsUpdate = handler.participantsUpdate.bind(conn)
    conn.onDelete = handler.delete.bind(conn)
    conn.connectionUpdate = connectionUpdate.bind(conn)
    conn.credsUpdate = saveCreds.bind(conn)

    conn.ev.on('messages.upsert', conn.handler)
    conn.ev.on('group-participants.update', conn.participantsUpdate)
    conn.ev.on('message.delete', conn.onDelete)
    conn.ev.on('connection.update', conn.connectionUpdate)
    conn.ev.on('creds.update', conn.credsUpdate)
    isInit = false
    return true
  }

  let pluginFolder = path.join(__dirname, 'plugins')
  let pluginFilter = filename => /\.js$/.test(filename)
  global.plugins = {}
  for (let filename of fs.readdirSync(pluginFolder).filter(pluginFilter)) {
    try {
      global.plugins[filename] = require(path.join(pluginFolder, filename))
    } catch (e) {
      console.error(e)
      delete global.plugins[filename]
    }
  }
  console.log('Loaded plugins:', Object.keys(global.plugins))

  global.reload = (_ev, filename) => {
    if (pluginFilter(filename)) {
      let dir = path.join(pluginFolder, filename)
      if (dir in require.cache) {
        delete require.cache[dir]
        if (fs.existsSync(dir)) console.log(`re - require plugin '${filename}'`)
        else {
          console.warn(`deleted plugin '${filename}'`)
          return delete global.plugins[filename]
        }
      } else console.log(`requiring new plugin '${filename}'`)
      let err = syntaxerror(fs.readFileSync(dir), filename)
      if (err) console.error(`syntax error while loading '${filename}'\n${err}`)
      else try {
        global.plugins[filename] = require(dir)
      } catch (e) {
        console.error(e)
      } finally {
        global.plugins = Object.fromEntries(Object.entries(global.plugins).sort(([a], [b]) => a.localeCompare(b)))
      }
    }
  }
  Object.freeze(global.reload)
  fs.watch(path.join(__dirname, 'plugins'), global.reload)
  global.reloadHandler()

  // Quick Test
  async function _quickTest() {
    let test = await Promise.all([
      cp.spawn('ffmpeg'),
      cp.spawn('ffprobe'),
      cp.spawn('ffmpeg', ['-hide_banner', '-loglevel', 'error', '-filter_complex', 'color', '-frames:v', '1', '-f', 'webp', '-']),
      cp.spawn('convert'),
      cp.spawn('magick'),
      cp.spawn('gm'),
      cp.spawn('find', ['--version'])
    ].map(p => {
      return Promise.race([
        new Promise(resolve => {
          p.on('close', code => {
            resolve(code !== 127)
          })
        }),
        new Promise(resolve => {
          p.on('error', _ => resolve(false))
        })
      ])
    }))
    let [ffmpeg, ffprobe, ffmpegWebp, convert, magick, gm, find] = test
    console.log('System check:', { ffmpeg, ffprobe, ffmpegWebp, convert, magick, gm, find })
    let s = global.support = {
      ffmpeg,
      ffprobe,
      ffmpegWebp,
      convert,
      magick,
      gm,
      find
    }
    Object.freeze(global.support)

    if (!s.ffmpeg) console.warn('⚠️ Please install ffmpeg for sending videos')
    if (s.ffmpeg && !s.ffmpegWebp) console.warn('⚠️ Stickers may not be animated without libwebp on ffmpeg')
    if (!s.convert && !s.magick && !s.gm) console.warn('⚠️ Stickers may not work without imagemagick')
  }

  _quickTest()
    .then(() => console.log('✅ Quick Test Done'))
    .catch(console.error)
}

// Start the bot
startBot().catch(err => {
  console.error('Failed to start bot:', err)
  process.exit(1)
})
